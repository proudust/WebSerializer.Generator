using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace Proudust.WebSerializer.Generator;

[Generator(LanguageNames.CSharp)]
public sealed partial class WebSerializerGenerator : IIncrementalGenerator
{
    public const string GenerateWebSerializerAttributeFullName = "Proudust.WebSerializer.Generator.GenerateWebSerializerAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("GenerateWebSerializerAttribute.g.cs", /* lang=c#-test */ """
                using System;

                namespace Proudust.WebSerializer.Generator;

                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
                internal sealed class GenerateWebSerializerAttribute : Attribute;
                """);
        });

        var typeDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            GenerateWebSerializerAttributeFullName,
            predicate: static (node, token) =>
            {
                return (node is ClassDeclarationSyntax
                                or StructDeclarationSyntax
                                or RecordDeclarationSyntax
                                or InterfaceDeclarationSyntax);
            },
            transform: static (context, token) =>
            {
                return (TypeDeclarationSyntax)context.TargetNode;
            });

        var source = typeDeclarations.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(source, static (context, source) =>
        {
            var (typeDeclaration, compilation) = source;

            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration, context.CancellationToken);
            if (typeSymbol is null)
            {
                return;
            }

            var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_");

            var sb = new StringBuilder();
            sb.Append(/* lang=c#-test */ """
                // <auto-generated/>

                using Cysharp.Web;

                """);

            var ns = typeSymbol.ContainingNamespace;
            if (!ns.IsGlobalNamespace)
            {
                sb.AppendLine("namespace ").Append(ns).AppendLine(";");
            }
            sb.AppendLine();

            var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            sb.AppendLine($$"""
                [WebSerializer(typeof({{typeSymbol.Name}}WebFormatter))]
                partial struct {{typeName}}
                {
                    sealed class {{typeSymbol.Name}}WebFormatter : IWebSerializer<{{typeName}}>
                    {
                        public void Serialize(ref WebSerializerWriter writer, {{typeName}} value, WebSerializerOptions options)
                        {

                        }
                    }
                }
                """);

            context.AddSource($"{fullType}.GenerateWebSerializer.g.cs", sb.ToString());
        });
    }
}
