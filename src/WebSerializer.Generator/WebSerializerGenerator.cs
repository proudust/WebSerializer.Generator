using System.Runtime.Serialization;
using System.Text;
using System.Text.Encodings.Web;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Proudust.WebSerializer.Generator;

[Generator(LanguageNames.CSharp)]
public sealed partial class WebSerializerGenerator : IIncrementalGenerator
{
    public const string GenerateWebSerializerAttributeFullName = "Proudust.WebSerializer.Generator.GenerateWebSerializerAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("GenerateWebSerializerAttribute.g.cs", /* lang=c#-test */ """
                using System;
                using System.Diagnostics;

                namespace Proudust.WebSerializer.Generator;

                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
                [Conditional("COMPILE_TIME_ONLY")]
                internal sealed class GenerateWebSerializerAttribute : Attribute;
                """);
        });

        var typeDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            GenerateWebSerializerAttributeFullName,
            predicate: static (node, token) =>
            {
                return (node is ClassDeclarationSyntax
                                or StructDeclarationSyntax
                                or RecordDeclarationSyntax
                                or InterfaceDeclarationSyntax);
            },
            transform: static (context, token) =>
            {
                return (TypeDeclarationSyntax)context.TargetNode;
            });

        var source = typeDeclarations.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(source, static (context, source) =>
        {
            var (typeDeclaration, compilation) = source;

            var semanticModel = compilation.GetSemanticModel(typeDeclaration.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration, context.CancellationToken);
            if (typeSymbol is null)
            {
                return;
            }

            var fullType = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                .Replace("global::", "")
                .Replace("<", "_")
                .Replace(">", "_");

            var sb = new StringBuilder();
            sb.Append(/* lang=c#-test */ """
                // <auto-generated/>

                using Cysharp.Web;

                """);

            var ns = typeSymbol.ContainingNamespace;
            if (!ns.IsGlobalNamespace)
            {
                sb.AppendLine("namespace ").Append(ns).AppendLine(";");
            }
            sb.AppendLine();

            var typeKeyword = (typeSymbol.IsRecord, typeSymbol.IsValueType) switch
            {
                (true, true) => "record struct",
                (true, false) => "record",
                (false, true) => "struct",
                (false, false) => "class",
            };
            var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
            sb.AppendLine($$"""
                [WebSerializer(typeof({{typeSymbol.Name}}WebFormatter))]
                partial {{typeKeyword}} {{typeName}}
                {
                    sealed class {{typeSymbol.Name}}WebFormatter : IWebSerializer<{{typeName}}>
                    {
                        public void Serialize(ref WebSerializerWriter writer, {{typeName}} value, WebSerializerOptions options)
                        {
                """);

            int i = 0;
            foreach (var (member, _) in typeSymbol
                .GetMembers()
                .OfType<IPropertySymbol>()
                .Select((symbol, i) =>
                {
                    var order = symbol.GetAttributes()
                        .FirstOrDefault(x => x.AttributeClass?.Name is nameof(DataMemberAttribute))
                        ?.NamedArguments
                        .FirstOrDefault(x => x.Key is nameof(DataMemberAttribute.Order))
                        .Value switch
                    {
                        { IsNull: true } => i,
                        { IsNull: false, Value: object v } => (int)v,
                        _ => throw new NotImplementedException(),
                    };
                    return (symbol, order);
                })
                .OrderBy((tuple) => tuple.order)
                .ToArray())
            {
                if (0 < i)
                {
                    sb.Append(/* lang=c#-test */ """
                                    writer.AppendConcatenate();

                        """);
                }

                sb.Append($$"""
                                writer.AppendNamePrefix();
                                writer.AppendRaw("{{UrlEncoder.Default.Encode(member.Name)}}=");
                                options.GetRequiredSerializer<{{member.Type.Name}}>().Serialize(ref writer, value.{{member.Name}}, options);

                    """);

                i++;
            }

            sb.AppendLine("""
                        }
                    }
                }
                """);

            context.AddSource($"{fullType}.GenerateWebSerializer.g.cs", sb.ToString());
        });
    }
}
